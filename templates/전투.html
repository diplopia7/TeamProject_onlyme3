{% extends 'project.html' %}

{% block title %}스토리 선택형 삼국지 TCG{% endblock %}
{% load static %}
{% block style %}
    <style>
        header {
            background-image: url('/static/img/background.jpg');
            height: 140px;
            width: 100%
        }

        .hover figure img {
            -webkit-transition: .3s ease-in-out;
            transition: .3s ease-in-out
        }

        .hover figure:hover img {
            opacity: .6
        }

        #logo {
            width: 515px;
            height: 115px;
            float: left;
            margin-top: 15px
        }

        .gamestart {
            list-style: none;
            position: absolute;
            left: 44%;
            margin-top: 10px

        }

        .gamestart img {
            width: 250px;
            height: 120px;
            border-radius: 50px
        }

        #qm1, #qm2 {
            position: absolute;
            display: flex;
            left: 84%;
            margin-top: 15px;
            height: 47px
        }

        #qm img {
            height: 45px;
            position: absolute
        }

        #qmenu1 img {
            margin-top: -1px
        }

        #qmenu2 {
            margin-left: 150px
        }

        #qmenu3 img {
            margin-top: -0.5px
        }

        #qmenu4 {
            margin-left: 24px
        }

        nav {
            width: 100%;
            position: relative;
            background-image: url('/static/img/navbg1.png');
            height: 120px
        }

        nav div {
            position: relative;
            margin-left: 3.5%;
            display: flex;
            margin-top: 8px;
            margin-bottom: 8px
        }

        nav img {
            height: 75px;
            position: relative
        }

        #mmenu2 {
            left: 23%
        }

        #mmenu3 {
            left: 43%;
            bottom: 2px
        }

        a {
            text-decoration: none;
            color: brown;
        }

        a:hover {
            color: red;
        }

        #gamename {
            color: rgb(46, 11, 129);
            font-size: 30px;
            font-weight: bold;
            position: absolute;
            z-index: 1;
            text-align: center;
            top: 80px;
            left: 65px;
        }

        #gameplay {
            font-size: 100px;
            position: absolute;
            z-index: 1;
            text-align: center;
            bottom: 150px;
            left: 450px;
        }

        #gamedescription {
            color: white;
            font-size: 40px;
            position: absolute;
            z-index: 1;
            text-align: center;
            top: 350px;
            left: 580px;
        }

        #quit {
            color: white;
            font-size: 40px;
            position: absolute;
            z-index: 1;
            text-align: center;
            top: 450px;
            left: 630px;
        }

        .cardfield {
            border: 3px solid rgb(68, 67, 67);
            width: 85px;
            height: 122px
        }

        .cardfield img {
            object-fit: cover
        }

        .cardfield p {
            position: absolute;
            background-color: rgba(255, 255, 255, 50%);
            top: -50px;
            width: 80px;
            text-align: center;
        }

        #field1 {
            position: absolute;
            z-index: 1;
            left: 300px;
            top: 200px;
        }

        #field2 {
            position: absolute;
            z-index: 1;
            left: 500px;
            top: 200px;
        }

        #field3 {
            position: absolute;
            z-index: 1;
            left: 700px;
            top: 200px;
        }

        #field4 {
            position: absolute;
            z-index: 1;
            left: 900px;
            top: 200px;
        }

        #field5 {
            position: absolute;
            z-index: 1;
            left: 400px;
            top: 50px;
        }

        #field6 {
            position: absolute;
            z-index: 1;
            left: 600px;
            top: 50px;
        }

        #field7 {
            position: absolute;
            z-index: 1;
            left: 800px;
            top: 50px;
        }

        #field8 {
            position: absolute;
            z-index: 1;
            left: 300px;
            top: 380px;
        }

        #field9 {
            position: absolute;
            z-index: 1;
            left: 500px;
            top: 380px;
        }

        #field10 {
            position: absolute;
            z-index: 1;
            left: 700px;
            top: 380px;
        }

        #field11 {
            position: absolute;
            z-index: 1;
            left: 900px;
            top: 380px;
        }

        #field12 {
            position: absolute;
            z-index: 1;
            left: 400px;
            top: 530px;
        }

        #field13 {
            position: absolute;
            z-index: 1;
            left: 600px;
            top: 530px;
        }

        #field14 {
            position: absolute;
            z-index: 1;
            left: 800px;
            top: 530px;
        }

        #field15 {
            position: absolute;
            z-index: 1;
            left: 150px;
            top: 200px;
        }

        #field16 {
            position: absolute;
            z-index: 1;
            left: 1060px;
            top: 380px;
        }

        #playerstatus {
            border: 3px solid black;
            width: 400px;
            height: 200px;
            position: absolute;
            z-index: 1;
            bottom: 5px;
            font-size: 30px;
            background-color: rgb(86, 94, 19);
            color: white;
        }

        #enemystatus {
            border: 3px solid black;
            width: 400px;
            height: 200px;
            position: absolute;
            z-index: 1;
            right: 0;
            top: 0;
            font-size: 30px;
            background-color: rgb(86, 94, 19);
            color: white
        }

        #main_menu {
            position: absolute;
            z-index: 1;
            left: 200px
        }

        #menu {
            /* border: 1px solid black; */
            position: absolute;
            z-index: 1;
            right: 50px;
            bottom: 250px;
        }

        .button {
            font-size: 20px;
            padding: 5px;
            margin: 5px;
            width: 100px;
        }

        #playercard {
            position: absolute;
            z-index: 1;
            /* border: 1px solid black; */
            bottom: 15px;
            left: 500px;
        }

        #enemycard {
            position: absolute;
            z-index: 1;
            top: 15px;
            left: 5px;
        }

        #cardbtn, #cardbtn2, #normallocation, #magiclocation {
            position: absolute;
            z-index: 1;
            border: 1px solid black;
            left: 500px;
            top: 350px;
            background-color: darkgrey;
            display: none;
        }

        .attack_enemy {
            border: 3px solid red;
        }

        .attack_mode {
            border: 3px solid blue;
        }

        .cardfield {
            z-index: 99;
            margin-left: 60px
        }
        form input{
            display: none;
        }

    </style>
{% endblock %}
{% block content %}
    <audio src="{% static 'resources/music/battle action.ogg' %}" autoplay="autoplay" loop="loop"></audio>
    <div id="main_menu" style="position:absolute; z-index:0">
        <img src="{% static 'resources/img/background/background3.jpg' %}" width="1500" height="840" alt>
        <div id="cardfield1">
            <div id="field1" class="cardfield"></div>
            <div id="field2" class="cardfield"></div>
            <div id="field3" class="cardfield"></div>
            <div id="field4" class="cardfield"></div>
            <div id="field5" class="cardfield"></div>
            <div id="field6" class="cardfield"></div>
            <div id="field7" class="cardfield"></div>
            <div id="field15" class="cardfield"></div>
        </div>
        <div id="cardfield2">
            <div id="field8" class="cardfield"></div>
            <div id="field9" class="cardfield"></div>
            <div id="field10" class="cardfield"></div>
            <div id="field11" class="cardfield"></div>
            <div id="field12" class="cardfield"></div>
            <div id="field13" class="cardfield"></div>
            <div id="field14" class="cardfield"></div>
            <div id="field16" class="cardfield"></div>
        </div>
        <div id="playerstatus">
            <div style="margin-top:10px; margin-left:10px">플레이어</div>
            <div style="margin-left:10px">체력 : <span id="playerhp">{{ request.session.hp }}</span> 전술 : <span
                    id="player전술">{{ request.session.skill }}</span></div>
            <div style="margin-left:10px">통솔 : <span id="player통솔">{{ request.session.command }}</span> 지력: <span
                    id="player지력">{{ request.session.inteli }}</span></div>
            <div style="margin-left:10px">무력 : <span id="player무력">{{ request.session.power }}</span> 정치: <span
                    id="player정치">{{ request.session.politics }}</span></div>
        </div>
        <div id="enemystatus">
            <div style="margin-top:10px; margin-left:10px">여몽</div>
            <div style="margin-left:10px">체력 : <span id="enemyhp"></span> 전술 : <span id="enemy전술">공방일체</span></div>
            <div style="margin-left:10px">통솔 : <span id="enemy통솔">91</span> 지력: <span id="enemy지력">89</span></div>
            <div style="margin-left:10px">무력 : <span id="enemy무력">81</span> 정치: <span id="enemy정치">0</span></div>
        </div>
        <div id="menu">
            {#            이병휘 효과음#}
            <button id="giveUp" type="button" class="button" onclick="buttonsound()">항복</button>
            <button id="fullField" type="button" class="button" onclick="buttonsound()">풀필드</button>
            <br>
            <button id="endturn" type="button" class="button" onclick="buttonsound()">턴 종료</button>
            <br>
            <button id="draw" type="button" class="button" onclick="drawsound()">드로우</button>
            <audio class="drawaudio" src='{% static "/resources/sfx/card_draw.wav" %}'></audio>
            <br>
            <button id="grave" type="button" class="button">무덤효과</button>
            <br>
            <button id="fight" type="button" class="button" onclick="buttonsound()">전투</button>
            <br>
            <button id="skill" type="button" class="button">전술스킬</button>
            <br>
        </div>
        <div id="playercard"></div>
        <div id="enemycard"></div>
        <div id="cardbtn">
            {#            이병휘 효과음#}
            <button id="attackbtn" type="button" class="button" onclick="buttonsound()">공격</button>
            <button id="defencebtn" type="button" class="button" onclick="buttonsound()">방어</button>
            <audio class="buttonaudio" src='{% static "/resources/sfx/button.wav" %}'></audio>
        </div>
        <div id="cardbtn2">
            <button id="frontbtn" type="button" class="button" onclick="buttonsound()">앞면</button>
            <button id="backbtn" type="button" class="button" onclick="buttonsound()">뒷면</button>
        </div>
        <div id="normallocation">
            <button id="loc1" type="button" class="button" onclick="cardpositionsound()">1</button>
            <button id="loc2" type="button" class="button" onclick="cardpositionsound()">2</button>
            <button id="loc3" type="button" class="button" onclick="cardpositionsound()">3</button>
            <button id="loc4" type="button" class="button" onclick="cardpositionsound()">4</button>
            <audio class="cardpositionaudio" src='{% static "/resources/sfx/card_position.wav" %}'></audio>
        </div>
        <div id="magiclocation">
            <button id="loc5" type="button" class="button" onclick="cardpositionsound()">1</button>
            <button id="loc6" type="button" class="button" onclick="cardpositionsound()">2</button>
            <button id="loc7" type="button" class="button" onclick="cardpositionsound()">3</button>
        </div>
        <form id="btfrm" name="btfrm" method="post">
            {% csrf_token %}
            <input id="player_hp" name="player_hp" value="">
            <input id="win" name="win" value="">
        </form>
    </div>
{% endblock %}

{% block jscript %}

    <script>
        let hp1 = {{ request.session.hp }};
        let hp2 = 100;
        let player_hp = document.getElementById('player_hp');
        let win_form = document.getElementById('win');
        let playerhp = document.getElementById('playerhp');
        player_hp.value = hp1;
        playerhp.innerHTML = hp1;
        enemyhp.textContent = hp2;
        let loc_attack_card;
        let loc_attacked_card;

        let turn = 'player';

        let giveUp = document.getElementById('giveUp');
        let fullField = document.getElementById('fullField');
        let endturn = document.getElementById('endturn');
        let skill = document.getElementById('skill');
        let fight = document.getElementById('fight');
        let grave = document.getElementById('grave');

        const player_skill = document.getElementById('player전술').innerText
        const player_commend = document.getElementById('player통솔').innerText
        const player_inteli = document.getElementById('player지력').innerText
        const player_power = document.getElementById('player무력').innerText
        const player_politics = document.getElementById('player정치').innerText

        const enemy_skill = document.getElementById('enemy전술').innerText
        const enemy_commend = document.getElementById('enemy통솔').innerText
        const enemy_inteli = document.getElementById('enemy지력').innerText
        const enemy_power = document.getElementById('enemy무력').innerText
        const enemy_politics = document.getElementById('enemy정치').innerText

        const enemy_name = document.getElementById('enemystatus').firstElementChild.innerText


        giveUp.style.display = 'none';
        fullField.style.display = 'none';
        endturn.disabled = true;
        console.log('at start disable fight button');
        fight.disabled = true;
        grave.disabled = true;

        let double_attack_player = 0;
        let half_attack_player = 0;
        let double_attack_enemy = 0;
        let half_attack_enemy = 0;

        let playergrave = [];
        let enemygrave = [];

        let buff_pair = {
            'field1': 0,
            'field2': 0,
            'field3': 0,
            'field4': 0,
            'field8': 0,
            'field9': 0,
            'field10': 0,
            'field11': 0
        };

        let buff_straight = {
            'field1': 0,
            'field2': 0,
            'field3': 0,
            'field4': 0,
            'field8': 0,
            'field9': 0,
            'field10': 0,
            'field11': 0
        };

        let active_shape = {
            'field1': 0,
            'field2': 0,
            'field3': 0,
            'field4': 0,
            'field8': 0,
            'field9': 0,
            'field10': 0,
            'field11': 0
        };

        let debuff_shape = {
            'field1': 0,
            'field2': 0,
            'field3': 0,
            'field4': 0,
            'field8': 0,
            'field9': 0,
            'field10': 0,
            'field11': 0
        };

        let color_available_player = true;
        let color_available_enemy = true;

        let user_special_add_stat = {
            'field1': 0,
            'field2': 0,
            'field3': 0,
            'field4': 0,
            'field8': 0,
            'field9': 0,
            'field10': 0,
            'field11': 0
        };
        let user_special_multiply_stat = {
            'field1': 1,
            'field2': 1,
            'field3': 1,
            'field4': 1,
            'field8': 1,
            'field9': 1,
            'field10': 1,
            'field11': 1
        };
        let user_skill_count = 0;
        let skill_available = true;
        let user_additional_turn = 0;
        let user_turn_skip = false;
        let user_skill_passive = true;
        let double_draw = false;
        let skill_risk = 0;
        let enemy_turn_damage = 0;
        let flip_available = true
        let grave_skill = 0;
        let active_card_for_grave_skills = [];

        // 메인 필드
        let main_field = {};

        let card_list = [
            '{% static "/resources/img/card/resize/back.png" %}',
            '{% static "/resources/img/card/resize/ace_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/ace_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/ace_of_spades.png" %}',
            '{% static "/resources/img/card/resize/ace_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/2_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/2_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/2_of_spades.png" %}',
            '{% static "/resources/img/card/resize/2_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/3_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/3_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/3_of_spades.png" %}',
            '{% static "/resources/img/card/resize/3_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/4_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/4_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/4_of_spades.png" %}',
            '{% static "/resources/img/card/resize/4_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/5_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/5_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/5_of_spades.png" %}',
            '{% static "/resources/img/card/resize/5_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/6_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/6_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/6_of_spades.png" %}',
            '{% static "/resources/img/card/resize/6_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/7_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/7_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/7_of_spades.png" %}',
            '{% static "/resources/img/card/resize/7_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/8_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/8_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/8_of_spades.png" %}',
            '{% static "/resources/img/card/resize/8_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/9_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/9_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/9_of_spades.png" %}',
            '{% static "/resources/img/card/resize/9_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/10_of_clubs.png" %}',
            '{% static "/resources/img/card/resize/10_of_diamonds.png" %}',
            '{% static "/resources/img/card/resize/10_of_spades.png" %}',
            '{% static "/resources/img/card/resize/10_of_hearts.png" %}',
            '{% static "/resources/img/card/resize/jack_of_clubs2.png" %}',
            '{% static "/resources/img/card/resize/jack_of_diamonds2.png" %}',
            '{% static "/resources/img/card/resize/jack_of_spades2.png" %}',
            '{% static "/resources/img/card/resize/jack_of_hearts2.png" %}',
            '{% static "/resources/img/card/resize/queen_of_clubs2.png" %}',
            '{% static "/resources/img/card/resize/queen_of_diamonds2.png" %}',
            '{% static "/resources/img/card/resize/queen_of_spades2.png" %}',
            '{% static "/resources/img/card/resize/queen_of_hearts2.png" %}',
            '{% static "/resources/img/card/resize/king_of_clubs2.png" %}',
            '{% static "/resources/img/card/resize/king_of_diamonds2.png" %}',
            '{% static "/resources/img/card/resize/king_of_spades2.png" %}',
            '{% static "/resources/img/card/resize/king_of_hearts2.png" %}',
            '{% static "/resources/img/card/resize/black_joker.png" %}',
            '{% static "/resources/img/card/resize/red_joker.png" %}'];

        //소리 이병휘
        function drawsound() {
            var audio = document.querySelector('.drawaudio');
            audio.play()
        }

        function attacksound() {
            var audio = document.querySelector('.attackaudio');
            audio.play()
        }

        function cardpositionsound() {
            var audio = document.querySelector('.cardpositionaudio');
            audio.play()
        }

        function firesound() {
            var audio = document.querySelector('.fireaudio');
            audio.play()
        }

        function bighitsound() {
            var audio = document.querySelector('.bighitaudio');
            audio.play()
        }

        function buffsound() {
            var audio = document.querySelector('.buffaudio');
            audio.play()
        }

        function buttonsound() {
            var audio = document.querySelector('.buttonaudio');
            audio.play()
        }


        // 섞섞
        function shuffle(array) {
            array.sort(() => Math.random() - 0.5);
        }

        // 배열 청소
        let clear_field = (array) => {
            while (array.hasChildNodes()) {
                array.removeChild(array.lastElementChild);
            }
        }

        // 턴종료 누르면 상대턴 시작
        endturn?.addEventListener('click', () => {
            if (enemy_turn_damage) attack_directly('player', enemy_turn_damage);
            if (user_additional_turn) {
                user_additional_turn--;
                if (!user_additional_turn) endturn.innerText = '턴 종료'
            } else {
                turn = 'enemy';
                enemy_turn();
                if (skill_available) skill.disabled = false;
            }
            if (user_turn_skip) {
                user_turn_skip = false;
                alert('상대 턴이 한번 더 진행됩니다');
                enemy_turn();
            }
            flip_available = true;
            card_location();
            fullField.disabled = false;
            endturn.disabled = true;
            if (player_deck[0]) draw.disabled = false;
            if (grave_skill) grave.disabled = false;
            fight.innerText = '전투';
            playercard.style.pointerEvents = 'auto';
        });

        let fight_available = false;
        let fight_mode = false;
        fight?.addEventListener('click', () => {
            if (!fight_mode) {
                fight_mode = true;
                fight.innerText = '취소';
                draw.disabled = true;
                playercard.style.pointerEvents = 'none';
            } else {
                fight_mode = false;
                fight.innerText = '전투';
                if (player_deck[0]) draw.disabled = false;
                playercard.style.pointerEvents = 'auto';
            }
            card_location();
        });

        // 기본 스탯 판단 함수
        const card_stat_basic = (cardid) => {
            let stat = Math.floor((cardid - 1) / 4) + 1;
            switch (stat) {
                case 11:
                    stat = 'jack';
                    break;
                case 12:
                    stat = 'queen';
                    break;
                case 13:
                    stat = 'king';
                    break;
                case 14:
                    stat = 10000;
                    break;
                default:
                    break;
            }
            if (cardid === 3) stat = 11;
            return stat;
        };
        const card_num = (cardid) => {
            return Math.floor((cardid - 1) / 4) + 1;
        };
        // 기본 모양 판단 함수
        const card_shape_basic = (cardid) => {
            let shape;
            switch (cardid % 4) {
                case 0:
                    shape = 'heart';
                    break;
                case 1:
                    shape = 'club';
                    break;
                case 2:
                    shape = 'diamond';
                    break;
                case 3:
                    shape = 'spade';
                    break;
            }
            if (cardid >= 53) shape = 'joker';
            return shape;
        };
        // 기본 색깔 판단 함수
        const card_color_basic = (cardid) => {
            let color = 'black';
            if (cardid % 2 === 0) color = 'red';
            return color;
        };

        // 플레이어 덱 만들기
        let main_deck = [];
        let player_deck = [];
        let enemy_deck = [];

        // 플레이어 손패 만들기
        let player_hand = [];
        let enemy_hand = [];

        for (let i = 1; i <= 54; ++i) {
            main_deck.push(i);
        }
        shuffle(main_deck);

        // 카드 드로우 함수
        let draw_card = (hand, deck) => {
            hand.push(deck[0]);
            deck.shift();
        };

        // 절반씩 덱 생성
        for (let i = 0; i < 27; ++i) {
            draw_card(player_deck, main_deck)
        }
        for (let i = 0; i < 27; ++i) {
            draw_card(enemy_deck, main_deck)
        }


        playercard = document.getElementById('playercard');
        enemycard = document.getElementById('enemycard');


        let magic_card = 0;
        let cardid = 0;
        let isattack = 1000;
        let isfront = 100;

        const enemy_turn = () => {
            console.log('enemy_turn start');
            console.log(enemy_hand);
            if (!enemy_hand[0]) {
                // 손이 텅 비었으면 무조건 드로우
                console.log('enemy_hand is empty');
                enemy_draw();
            } else {
                console.log("enemy do something");
                // 카드 뽑을 확률 1/4
                // 카드 배치 확률 1/2
                // 카드 공격 확률 1/4
                switch (Math.floor(Math.random() * 4)) {
                    case 0:
                        enemy_draw();
                        break;
                    case 1:
                    case 2:
                        if (ismagic(enemy_hand[0])) enemy_choose_card_magic(enemy_hand[0]);
                        else enemy_choose_card_normal(enemy_hand[0]);
                        break;
                    case 3:
                        enemy_attack_card();
                        break;
                }
            }
            card_location();
            turn = 'player';
        };

        // 동전 던지기
        const rnd = () => {
            return Math.floor(Math.random() * 2) === 1;
        };

        // 상대편 드로우
        const enemy_draw = () => {
            if (!enemy_deck[0]) {
                enemy_attack_card();  // 덱이 비었으면 공격
            } else {
                console.log("enemy_draw");
                draw_card(enemy_hand, enemy_deck);
                let a = document.createElement('img');
                a.src = card_list[0];
                enemycard.appendChild(a);
                var audio = new Audio('{% static "resources/sfx/card_draw.wav" %}')
                audio.play()
            }
        };
        // 노말카드 배치용
        const enemy_choose_card_normal = (cardid) => {
            if (isfieldfull_enemy_normal()) enemy_draw();  // 노말필드 가득차있으면 드로우
            else {
                console.log("enemy_choose_card_normal");
                let field = enemy_choose_field(cardid);
                let isattack = 1000;
                let isfront = 100;
                if (rnd()) isattack = 0;
                if (rnd()) isfront = 0;
                // 필드에 공격카드 없으면 무조건 공격배치
                if (!is_attack_card(main_field['field1']) &&
                    !is_attack_card(main_field['field2']) &&
                    !is_attack_card(main_field['field3']) &&
                    !is_attack_card(main_field['field4'])) isattack = 1000;
                let card_info = set_stat(cardid) + isattack + isfront + cardid;
                enemycard.removeChild(enemycard.lastElementChild);
                enemy_set_card(card_info, field);
            }
        }
        // 마법카드 배치용
        const enemy_choose_card_magic = (cardid) => {
            if (isfieldfull_enemy_normal()) {
                if (!enemy_deck[0]) {
                    // 드로우불가 마법카드 배치불가 맨앞카드는 마법카드
                    // 공격카드가 맨 앞에 올떄까지 카드 돌리기
                    for (let i = 0; i < enemy_hand.length; ++i) {
                        let temp = enemy_hand[0]
                        enemy_hand.shift()
                        enemy_hand.push(temp);
                        if (!ismagic(enemy_hand[0])) {
                            enemy_choose_card_normal(enemy_hand[0]);
                            break;
                        } else {
                            enemygrave.push(cardid);
                            set_card(field15, cardid);
                        }
                    }
                    // 손에 마법카드밖에 없음
                    // 가능 행동은 공격뿐
                    if (!is_attack_card(main_field['field1']) &&
                        !is_attack_card(main_field['field2']) &&
                        !is_attack_card(main_field['field3']) &&
                        !is_attack_card(main_field['field4'])) {
                        //공격도 불가, 패배
                        alert(`${enemy_name}이 더이상 행동할 수 없습니다!`);
                        win_game('player');
                    } else enemy_attack_card();
                } else enemy_draw();  // 마법필드 가득차있으면 드로우
            } else {
                console.log("enemy_choose_card_magic");
                let field = enemy_choose_field(cardid);
                let magic_card = 10000;
                let isattack = 1000;
                let isfront = 100;
                let card_info = magic_card + isattack + isfront + cardid;
                enemycard.removeChild(enemycard.lastElementChild);
                if (active_magic_card(cardid, 'enemy')) enemy_set_card(card_info, field);
            }
        }

        // 카드 놓을 장소 고르기 (무작위)
        const enemy_choose_field = (cardid) => {
            console.log(`enemy_choose_field`);
            let field = [];
            if (!ismagic(cardid)) {
                if (!main_field['field1']) field.push(1);
                if (!main_field['field2']) field.push(2);
                if (!main_field['field3']) field.push(3);
                if (!main_field['field4']) field.push(4);
            } else {
                if (!main_field['field5']) field.push(5);
                if (!main_field['field6']) field.push(6);
                if (!main_field['field7']) field.push(7);
            }
            if (!field[0]) return 'full'
            else return field[Math.floor(Math.random() * field.length)];
        };
        // 카드정보와 필드정보를 받아 메인필드에 삽입
        const enemy_set_card = (card, field) => {
            console.log(`enemy_set_card, card: ${card}, field: ${field}`);
            switch (field) {
                case 1:
                    main_field['field1'] = card;
                    break;
                case 2:
                    main_field['field2'] = card;
                    break;
                case 3:
                    main_field['field3'] = card;
                    break;
                case 4:
                    main_field['field4'] = card;
                    break;
                case 5:
                    main_field['field5'] = card;
                    break;
                case 6:
                    main_field['field6'] = card;
                    break;
                case 7:
                    main_field['field7'] = card;
                    break;
            }
            enemy_hand.shift();
            card_location();
        };

        // 적 공격 함수
        const enemy_attack_card = () => {
            if (!is_attack_card(main_field['field1']) &&
                !is_attack_card(main_field['field2']) &&
                !is_attack_card(main_field['field3']) &&
                !is_attack_card(main_field['field4'])) {
                if (!enemy_hand[0]) {
                    // 손패가 없는 상황에서 드로우를 못 해서 공격으로 넘어왔다.
                    // 덱에도 손에도 카드가 없다. 근데 공격가능한 카드도 없다. 행동불가
                    alert(`${enemy_name}이 더이상 행동할 수 없습니다!`);
                    win_game('player');
                } else if (ismagic(enemy_hand[0])) {
                    enemy_choose_card_magic(enemy_hand[0]);  // 공격가능 카드가 없으면 카드배치
                } else {
                    enemy_choose_card_normal(enemy_hand[0]);  // 공격가능 카드가 없으면 카드배치
                }
            } else {
                console.log(`enemey try attack`);
                let attack_available_enemey = []
                for (let i = 1; i <= 4; ++i) {
                    if (main_field[`field${i}`] % 10000 >= 1000) {
                        attack_available_enemey.push(i);
                    }
                }
                console.log(attack_available_enemey);
                if (attack_available_enemey === []) {
                    // 공격 가능한 카드가 없으면 그냥 드로우
                    console.log(`attack not available`);
                    enemy_draw();
                } else {
                    console.log(`attack field1: field${attack_available_enemey[0]}`);
                    console.log(`attack field2: field${attack_available_enemey[1]}`);
                    console.log(`attack field3: field${attack_available_enemey[2]}`);
                    console.log(`attack field4: field${attack_available_enemey[3]}`);
                    let rnd_attacker = Math.floor(Math.random() * attack_available_enemey.length)
                    let field_id = attack_available_enemey[rnd_attacker];
                    let attack_card = main_field[`field${field_id}`];
                    alert(`field${field_id}의 ${attack_card}에게 공격받고 있다!`);
                    if (attack_card % 1000 < 100) {
                        main_field[`field${field_id}`] += 100;
                    }
                    loc_attack_card = `field${field_id}`;
                    loc_attacked_card = `field${field_id + 7}`;
                    if (main_field[loc_attacked_card]) card_attack('enemy');
                    else if (stat_now(loc_attack_card) === 'joker') {
                        console.log(`joker can't attack directly`);
                        enemy_draw();
                    } else {
                        let damage = Number(stat_now(loc_attack_card))
                        attack_directly('enemy', damage);
                    }
                }
            }


        };


        // 카드 배치 함수
        // (배치구역, 카드번호)
        const set_card = (place, cardid3) => {
            console.log(`set_card: ${cardid3}`);

            let a = document.createElement('img');
            a.src = card_list[cardid3];
            eval(place).appendChild(a);
        };
        const set_card_rotate = (place, cardid3) => {
            console.log(`set_card_rotate: ${cardid3}`);

            let a = document.createElement('img');
            a.src = card_list[cardid3];
            a.style.transform = 'rotate(90deg)';
            eval(place).appendChild(a);
        };


        // 손에 카드 넣기
        // checkhand(손, 장소)
        const checkhand = (hand, place) => {
            while (place.hasChildNodes()) {
                place.removeChild(place.firstChild);
            }

            for (let i = 0; i < hand.length; ++i) {
                let a = document.createElement('img')
                a.id = `${i}_${hand[i]}`;
                a.className = 'card_in_hand';
                a.src = card_list[hand[i]];

                handf = () => {
                    console.log(`handf with ${i}, ${hand[i]}`);
                    if (ismagic(hand[i]) && isfieldfull_player_magic()) alert('마법카드를 더 이상 놓을 수 없습니다');
                    else if (!ismagic(hand[i]) && isfieldfull_player_normal()) alert('전투카드를 더 이상 놓을 수 없습니다');
                    else active01(i, hand[i]);
                };
                a.addEventListener('click', handf);
                place.appendChild(a)
            }
        };

        // 스킬 타입 지정 함수
        const skill_type = () => {
            switch (player_skill) {
                case '화계':
                case '매복지독':
                    return '지력스킬'
                case '인중여포':
                case '대타격':
                    return '무력스킬'
                default :
                    return '일반스킬'
            }
        }


        //첫 턴 자동 함수
        const first_turn = () => {
            // 처음 4장씩 드로우
            for (let i = 0; i < 4; ++i) {
                draw_card(player_hand, player_deck);
                enemy_draw();
            }
            checkhand(player_hand, playercard);

            // 플레이어 스텟 비교 효과
            let first_msg = '';
            if (Number(player_commend) < Number(enemy_commend)) {
                for (let i = 0; i < 10; ++i) {
                    player_deck.shift();
                }
                first_msg += `
                ${enemy_name}보다 통솔이 낮습니다!
                `;
                first_msg += `덱에서 카드 10장을 제외합니다
                `;
            }
            if (Number(player_inteli) < Number(enemy_inteli)) {
                if (skill_type() === '지력스킬') {
                    skill_available = false;
                    first_msg += `${enemy_name}보다 지력이 낮습니다!
                `;
                    first_msg += `${player_skill}을/를 사용할 수 없습니다
                `;
                }
            }
            if (Number(player_power) < Number(enemy_power)) {
                if (skill_type() === '무력스킬') {
                    skill_available = false;
                    first_msg += `${enemy_name}보다 무력이 낮습니다!
                `;
                    first_msg += `${player_skill}을/를 사용할 수 없습니다
                `;
                }
            }
            if (first_msg) alert(first_msg);
            check_user_skill(player_skill);
            skill.disabled = !skill_available;
        };


        // 마법카드 판단 함수
        const ismagic = (cardid3) => {
            return cardid3 >= 41 && cardid3 <= 52;
        };

        // 필드 빈자리 확인용
        const isfieldfull_enemy_normal = () => {
            return main_field['field1'] && main_field['field2'] && main_field['field3'] && main_field['field4'];
        };
        const isfieldfull_enemy_magic = () => {
            return main_field['field5'] && main_field['field6'] && main_field['field7'];
        };
        const isfieldfull_player_normal = () => {
            return main_field['field8'] && main_field['field9'] && main_field['field10'] && main_field['field11'];
        };
        const isfieldfull_player_magic = () => {
            return main_field['field12'] && main_field['field13'] && main_field['field14'];
        };


        // 필드에 카드 넣기
        // 상대 턴 진행
        const loc1f = () => {
            normallocation.style.display = 'none';
            main_field['field8'] = set_stat(cardid) + isattack + isfront + cardid;
            finish_turn();
        };
        const loc2f = () => {
            normallocation.style.display = 'none';
            main_field['field9'] = set_stat(cardid) + isattack + isfront + cardid;
            finish_turn();
        };
        const loc3f = () => {
            normallocation.style.display = 'none';
            main_field['field10'] = set_stat(cardid) + isattack + isfront + cardid;
            finish_turn();
        };
        const loc4f = () => {
            normallocation.style.display = 'none';
            main_field['field11'] = set_stat(cardid) + isattack + isfront + cardid;
            finish_turn();
        };
        const loc5f = () => {
            magiclocation.style.display = 'none';
            if (active_magic_card(cardid, 'player')) main_field['field12'] = magic_card + isattack + isfront + cardid;
            else {
                playergrave.push(cardid);
                set_card(field16, cardid);
            }
            finish_turn();
        };
        const loc6f = () => {
            magiclocation.style.display = 'none';
            if (active_magic_card(cardid, 'player')) main_field['field13'] = magic_card + isattack + isfront + cardid;
            else {
                playergrave.push(cardid);
                set_card(field16, cardid);
            }
            finish_turn();
        };
        const loc7f = () => {
            magiclocation.style.display = 'none';
            if (active_magic_card(cardid, 'player')) main_field['field14'] = magic_card + isattack + isfront + cardid;
            else {
                playergrave.push(cardid);
                set_card(field16, cardid);
            }
            finish_turn();
        };

        const set_stat = (cardid) => {
            let card_stat = 0;
            if (!ismagic(cardid)) card_stat = card_stat_basic(cardid) * 100000;
            return card_stat;
        };


        // 드로우 버튼 작용
        let draw = document.getElementById('draw');
        draw.addEventListener("click", () => {
            draw_card(player_hand, player_deck);
            checkhand(player_hand, playercard);
            if (skill_risk) {
                attack_directly('enemy', skill_risk);
                skill_risk = 0;
            }
            if (double_draw && player_deck[0]) {
                draw.innerText = '드로우 (20피해)'
                double_draw = false;
                skill_risk = 20;
            } else {
                finish_turn();
            }
        });

        // 앞뒤판단 - 공격방향
        const attackf = () => {
            console.log(`in attackf = cardid: ${cardid}, magic_card: ${magic_card}`)
            attackbtn.removeChild(attackbtn.lastElementChild);
            defencebtn.removeChild(defencebtn.lastElementChild);
            cardbtn.style.display = 'none';
            cardbtn2.style.display = 'block';
            set_card(frontbtn, cardid);
            set_card(backbtn, 0);
        };
        // 앞뒤판단 - 수비방향
        const defencef = () => {
            isattack = 0;
            attackbtn.removeChild(attackbtn.lastElementChild);
            defencebtn.removeChild(defencebtn.lastElementChild);
            cardbtn.style.display = 'none';
            cardbtn2.style.display = 'block';
            set_card_rotate(frontbtn, cardid);
            set_card_rotate(backbtn, 0);
        };
        // 앞방향 배치지정
        const frontf = () => {
            frontbtn.removeChild(frontbtn.lastElementChild);
            backbtn.removeChild(backbtn.lastElementChild);
            cardbtn2.style.display = 'none';
            normallocation.style.display = 'block';

        };
        // 뒷방향 배치지정
        const backf = () => {
            isfront = 0;
            frontbtn.removeChild(frontbtn.lastElementChild);
            backbtn.removeChild(backbtn.lastElementChild);
            cardbtn2.style.display = 'none';
            normallocation.style.display = 'block';
        };
        // 손 안의 카드의 위치와 카드의 변수값을 받아 실행되는 함수
        let active01 = (handid, cardid3) => {
            cardid = cardid3;
            magic_card = 0;
            isattack = 1000;
            isfront = 100;
            console.log(`receive active01: ${handid}, ${cardid}`);
            // 마법카드 여부 확인
            if (ismagic(cardid)) magic_card = 10000;


            player_hand.splice(handid, 1); // 뽑은 카드 손에서 지우기
            checkhand(player_hand, playercard);
            playercard.style.pointerEvents = 'none';
            // 공수여부 판단
            if (magic_card === 10000) {
                magiclocation.style.display = 'block';
            } else {
                cardbtn.style.display = 'block';
                set_card(attackbtn, cardid);
                set_card_rotate(defencebtn, cardid);
            }


            attackbtn.addEventListener("click", attackf);
            defencebtn.addEventListener("click", defencef);
            frontbtn.addEventListener('click', frontf);
            backbtn.addEventListener('click', backf);
            loc1.addEventListener('click', loc1f);
            loc2.addEventListener('click', loc2f);
            loc3.addEventListener('click', loc3f);
            loc4.addEventListener('click', loc4f);
            loc5.addEventListener('click', loc5f);
            loc6.addEventListener('click', loc6f);
            loc7.addEventListener('click', loc7f);
            loc1.disabled = !!main_field['field8'];
            loc2.disabled = !!main_field['field9'];
            loc3.disabled = !!main_field['field10'];
            loc4.disabled = !!main_field['field11'];
            loc5.disabled = !!main_field['field12'];
            loc6.disabled = !!main_field['field13'];
            loc7.disabled = !!main_field['field14'];
        };
        // 최종 배치 함수
        // loc1 = 11150 === 1번 자리에 있는 마법카드, 공격배치, 앞면인 50번 카드
        // EventListener, 필드 전역 일괄 청소 후 카드 배치 실행
        // main_field에서 모든 필드의 카드 정보를 받아 배치
        // 가장 일 많이 하는 녀석
        let card_location = () => {
            console.log(`========${turn}'s turn========`);
            console.log(`double_attack_player:${double_attack_player}`);
            console.log(`double_attack_enemy:${double_attack_enemy}`);
            console.log(`half_attack_player:${half_attack_player}`);
            console.log(`half_attack_enemy:${half_attack_enemy}`);
            console.log('card_location');
            console.log(main_field);

            check_buff_number();
            console.log(buff_pair);
            console.log(buff_straight);
            check_buff_shape();
            console.log(active_shape);
            console.log(debuff_shape);
            check_buff_color();
            if (!player_deck[0]) giveUp.style.display = 'inline_block';
            check_full_field();
            if (user_skill_passive) check_user_skill(player_skill);
            if (playergrave.length > 1) check_grave();
            console.log('playergraveplayergraveplayergraveplayergraveplayergrave');
            console.log(playergrave);

            defencebtn.removeEventListener("click", attackf);
            defencebtn.removeEventListener("click", defencef);
            frontbtn.removeEventListener('click', frontf);
            backbtn.removeEventListener('click', backf);
            loc1.removeEventListener('click', loc1f);
            loc2.removeEventListener('click', loc2f);
            loc3.removeEventListener('click', loc3f);
            loc4.removeEventListener('click', loc4f);
            loc5.removeEventListener('click', loc5f);
            loc6.removeEventListener('click', loc6f);
            loc7.removeEventListener('click', loc7f);
            clear_field(field1);
            clear_field(field2);
            clear_field(field3);
            clear_field(field4);
            clear_field(field5);
            clear_field(field6);
            clear_field(field7);
            clear_field(field8);
            clear_field(field9);
            clear_field(field10);
            clear_field(field11);
            clear_field(field12);
            clear_field(field13);
            clear_field(field14);
            for (let loc in main_field) {
                let card = main_field[loc];
                let card_info = card % 10000;
                let cardid = card_info % 100;
                let cardstat = card_stat_basic(cardid);
                switch ((card_info - cardid) / 100) {
                    case 0:
                        set_card_rotate(loc, 0);
                        display_stat(loc, cardstat);
                        if (isenemy_normal(loc)) {
                            eval(loc).lastElementChild.style.display = 'none'
                        }
                        break;
                    case 1:
                        set_card_rotate(loc, cardid)
                        display_stat(loc, cardstat);
                        break;
                    case 10:
                        set_card(loc, 0);
                        display_stat(loc, cardstat);
                        if (isenemy_normal(loc)) {
                            eval(loc).lastElementChild.style.display = 'none'
                        } else if (isplayer_normal(loc)) {
                            fight_available = true;
                            temp = () => {
                                to_front(loc);
                            }
                            temp_over = () => {
                                card_mouseover(loc);
                            }
                            temp_out = () => {
                                card_mouseout(loc);
                            }
                            if (fight_mode) {
                                eval(loc).firstElementChild.addEventListener('click', temp);
                                eval(loc).firstElementChild.addEventListener('mouseover', temp_over);
                                eval(loc).firstElementChild.addEventListener('mouseout', temp_out);
                            }
                        }
                        break;
                    case 11:
                        set_card(loc, cardid);
                        display_stat(loc, cardstat);
                        if (isplayer_normal(loc)) {
                            fight_available = true;
                            let loc_enemy = loc.slice(0, 5) + String(Number(loc.slice(5)) - 7);
                            temp = () => {
                                to_fight(loc, loc_enemy);
                            }
                            temp_over = () => {
                                to_fight_mouseover(loc, loc_enemy);
                            }
                            temp_out = () => {
                                to_fight_mouseout(loc, loc_enemy);
                            }
                            if (fight_mode && !(eval(loc).lastElementChild.innerText === 'joker' && !(main_field[loc_enemy]))) {
                                eval(loc).firstElementChild.addEventListener('click', temp);
                                eval(loc).firstElementChild.addEventListener('mouseover', temp_over);
                                eval(loc).firstElementChild.addEventListener('mouseout', temp_out);
                            }
                        }
                        break;
                    default:
                        alert(`${loc}에 ${card_info}의 카드가 들어옴`);
                }
                temp_flip = () => {
                    to_flip(loc);
                }
                temp_flip_over = () => {
                    card_mouseover(loc);
                }
                temp_flip_out = () => {
                    card_mouseout(loc);
                }
                if (!fight_mode && isplayer_normal(loc) && flip_available) {
                    eval(loc).firstElementChild.addEventListener('click', temp_flip);
                    eval(loc).firstElementChild.addEventListener('mouseover', temp_flip_over);
                    eval(loc).firstElementChild.addEventListener('mouseout', temp_flip_out);
                }


            }
            // 전투 가능/불가능 판단해서 전투버튼 활성화/비활성화
            fight.disabled = !fight_available;
        };

        // 스텟 표시 함수
        const display_stat = (place, cardstat) => {
            let a = document.createElement('p');
            if (cardstat === 10000) a.innerText = 'joker';
            else if (isplayer_normal(place)) {
                if (buff_straight[place] !== 0) cardstat = buff_straight[place];
                if (buff_pair[place] === 2) {
                    cardstat = cardstat * 2;
                } else if (buff_pair[place] === 3) {
                    cardstat = cardstat ** 3;
                } else if (buff_pair[place] === 4) {
                    cardstat = cardstat ** 4;
                }

                cardstat += user_special_add_stat[place];
                cardstat = cardstat * user_special_multiply_stat[place];

                if (double_attack_player)
                    for (let i = 0; i < double_attack_player; ++i) {
                        cardstat = cardstat * 2;
                    }
                if (half_attack_player)
                    for (let i = 0; i < half_attack_player; ++i) {
                        cardstat = cardstat / 2;
                    }
                if (debuff_shape[place])
                    for (let i = 0; i < debuff_shape[place]; ++i) {
                        cardstat = cardstat / 2;
                    }
                cardstat -= cardstat % 1;
                if (cardstat < 0) cardstat = 0;
                a.innerText = cardstat;
            } else if (isenemy_normal(place)) {
                if (buff_straight[place] !== 0) cardstat = buff_straight[place];
                if (buff_pair[place] === 2) {
                    cardstat = cardstat * 2;
                } else if (buff_pair[place] === 3) {
                    cardstat = cardstat ** 3;
                } else if (buff_pair[place] === 4) {
                    cardstat = cardstat ** 4;
                }
                if (double_attack_enemy)
                    for (let i = 0; i < double_attack_enemy; ++i) {
                        cardstat = cardstat * 2;
                    }
                if (half_attack_enemy)
                    for (let i = 0; i < half_attack_enemy; ++i) {
                        cardstat = cardstat / 2;
                    }
                if (debuff_shape[place])
                    for (let i = 0; i < debuff_shape[place]; ++i) {
                        cardstat = cardstat / 2;
                    }
                cardstat -= cardstat % 1;
                if (cardstat < 0) cardstat = 0;
                a.innerText = cardstat;
            } else a.innerText = cardstat;
            eval(place).appendChild(a);
        };

        const isplayer_normal = (loc) => {
            return loc === 'field8' || loc === 'field9' || loc === 'field10' || loc === 'field11';
        };
        const isplayer_magic = (loc) => {
            return loc === 'field12' || loc === 'field13' || loc === 'field14';
        };
        const isenemy_normal = (loc) => {
            return loc === 'field1' || loc === 'field2' || loc === 'field3' || loc === 'field4';
        };

        // 카드 돌리기
        const to_flip = (loc) => {
            if (main_field[loc] % 10000 > 1000) main_field[loc] -= 1000;
            else main_field[loc] += 1000;
            eval(loc).firstElementChild.removeEventListener('click', temp_flip);
            eval(loc).firstElementChild.removeEventListener('mouseover', temp_flip_over);
            eval(loc).firstElementChild.removeEventListener('mouseout', temp_flip_out);
            eval(loc).className = 'cardfield';
            {#endturn.disabled = false;#}
            {#draw.disabled = true;#}
            {#fight_mode = false;#}
            {#playercard.style.pointerEvents = 'none';#}
            {#card_location();#}
            {#skill.disabled = true;#}
            {#fight.disabled = true;#}
            finish_turn();
        };


        const card_mouseover = (loc) => {
            eval(loc).className += ' attack_mode';
        };

        const card_mouseout = (loc) => {
            eval(loc).className = 'cardfield';
        };

        // 카드 뒤집기
        const to_front = (loc) => {
            main_field[loc] += 100;
            eval(loc).firstElementChild.removeEventListener('click', temp);
            eval(loc).firstElementChild.removeEventListener('mouseover', temp_over);
            eval(loc).firstElementChild.removeEventListener('mouseout', temp_out);
            fight.disabled = true;
            endturn.disabled = false;
            card_location();
        };


        const to_fight_mouseover = (loc, loc_enemy) => {
            eval(loc).className += ' attack_mode';
            eval(loc_enemy).className += ' attack_enemy';
        };

        const to_fight_mouseout = (loc, loc_enemy) => {
            eval(loc).className = 'cardfield';
            eval(loc_enemy).className = 'cardfield';
        };


        // 카드 공격
        const to_fight = (loc, loc_enemy) => {
            eval(loc).firstElementChild.removeEventListener('click', temp);
            eval(loc).firstElementChild.removeEventListener('mouseover', temp_over);
            eval(loc).firstElementChild.removeEventListener('mouseout', temp_out);
            let attack_stat = stat_now(loc);
            let loc_e = eval(loc_enemy);
            eval(loc).className = 'cardfield';
            loc_e.className = 'cardfield';

            if (main_field[loc_enemy]) {
                loc_attack_card = loc;
                loc_attacked_card = loc_enemy;
                card_attack('player');
            } else {
                attack_directly('player', attack_stat)
                finish_turn();
            }
            fight.disabled = true;
        };


        // 플레이어 턴 종료
        // 턴 종료 버튼만 누를 수 있음
        const finish_turn = () => {
            endturn.disabled = false;
            draw.disabled = true;
            fight_mode = false;
            playercard.style.pointerEvents = 'none';
            flip_available = false;
            skill.disabled = true;
            grave.disabled = true;
            card_location();
            fullField.disabled = true;
            fight.disabled = true;
            fight.innerText = '전투'
            draw.innerText = '드로우'
            if (user_additional_turn) endturn.innerText = `추가 턴 (${user_additional_turn})`
        };

        // HTML에 적은 값에서 현 스텟 불러오긔
        const stat_now = (field) => {
            return eval(field).lastElementChild.innerText;
        };

        // 공격 실행
        const card_attack = (turn) => {
            let attack_stat = stat_now(loc_attack_card);
            let attacked_stat = stat_now(loc_attacked_card);
            let attack_card = main_field[loc_attacked_card] % 10000 >= 1000;
            let attack_card_id = main_field[loc_attack_card] % 100;
            let attacked_card_id = main_field[loc_attacked_card] % 100;

            console.log(`${main_field[loc_attack_card]} attack ${main_field[loc_attacked_card]}`);
            console.log(`${attack_stat} attack ${attacked_stat}`);
            if (attack_card_id >= 53) {
                console.log(`joker attack ${attacked_stat}`);
                if (card_color_basic(attack_card_id) === card_color_basic(attacked_card_id))
                    attacked_stat = -1;
                else attacked_stat = 1;
            } else if (attacked_card_id >= 53) {
                if (card_color_basic(attack_card_id) === card_color_basic(attacked_card_id))
                    attacked_stat = 1;
                else attacked_stat = -1;
            } else {
                attacked_stat -= attack_stat;
            }

            if (main_field[loc_attacked_card] % 1000 < 100) main_field[loc_attacked_card] += 100;
            if (attacked_stat < 0) { // 공격한 카드의 스텟이 더 높은 경우
                delete_card_normal(loc_attacked_card);
                if (attack_card_id <= 53 && attacked_card_id <= 53  // 두 카드 전부 조커가 아니어야 직접 데미지
                    && attacked_card_id >= 4  // 맞는 카드가 에이스가 아니어야 직접 데미지
                    && attack_card)
                    attack_directly(turn, attacked_stat * -1);
            } else if (attacked_stat > 0) { // 공격한 카드의 스텟이 더 낮은 경우
                delete_card_normal(loc_attack_card);
                if (attack_card_id <= 53 && attacked_card_id <= 53  // 두 카드 전부 조커가 아니어야 직접 데미지
                    && attack_card_id >= 4)  // 공격하는 카드가 에이스가 아니어야 직접 데미지
                {
                    if (turn === 'player') attack_directly('enemy', attacked_stat);
                    else attack_directly('player', attacked_stat);

                }
            } else {
                // 같을 경우 모양에 따라 판단함 (직접데미지는 없음)
                let attack_card_shape = attack_card_id % 4;
                let attacked_card_shape = attacked_card_id % 4;

                if (attack_card_shape + 1 === attacked_card_shape ||
                    (attack_card_shape === 3 && attacked_card_shape === 0)) delete_card_normal(loc_attacked_card);
                else if (attack_card_shape - 1 === attacked_card_shape ||
                    (attack_card_shape === 0 && attacked_card_shape === 3)) delete_card_normal(loc_attack_card);
            }
            finish_turn();
        };

        // 일반 카드 제거
        const delete_card_normal = (card_loc) => {
            console.log(`${card_loc} is deleted!`);
            buff_pair[card_loc] = 0;
            debuff_shape[card_loc] = 0;
            active_shape[card_loc] = 0;
            user_special_add_stat[card_loc] = 0;
            user_special_multiply_stat[card_loc] = 1;
            switch (card_loc) {
                case 'field1':
                    clear_field(field15)
                    enemygrave.push(main_field['field1'] % 100)
                    delete main_field.field1;
                    set_card(field15, enemygrave[enemygrave.length - 1]);
                    color_available_enemy = true;
                    break;
                case 'field2':
                    clear_field(field15)
                    enemygrave.push(main_field['field2'] % 100)
                    delete main_field.field2;
                    set_card(field15, enemygrave[enemygrave.length - 1]);
                    color_available_enemy = true;
                    break;
                case 'field3':
                    clear_field(field15)
                    enemygrave.push(main_field['field3'] % 100)
                    delete main_field.field3;
                    set_card(field15, enemygrave[enemygrave.length - 1]);
                    color_available_enemy = true;
                    break;
                case 'field4':
                    clear_field(field15)
                    enemygrave.push(main_field['field4'] % 100)
                    delete main_field.field4;
                    set_card(field15, enemygrave[enemygrave.length - 1]);
                    color_available_enemy = true;
                    break;
                case 'field8':
                    clear_field(field16)
                    playergrave.push(main_field['field8'] % 100)
                    delete main_field.field8;
                    set_card(field16, playergrave[playergrave.length - 1]);
                    color_available_player = true;
                    break;
                case 'field9':
                    clear_field(field16)
                    playergrave.push(main_field['field9'] % 100)
                    delete main_field.field9;
                    set_card(field16, playergrave[playergrave.length - 1]);
                    color_available_player = true;
                    break;
                case 'field10':
                    clear_field(field16)
                    playergrave.push(main_field['field10'] % 100)
                    delete main_field.field10;
                    set_card(field16, playergrave[playergrave.length - 1]);
                    color_available_player = true;
                    break;
                case 'field11':
                    clear_field(field16)
                    playergrave.push(main_field['field11'] % 100)
                    delete main_field.field11;
                    set_card(field16, playergrave[playergrave.length - 1]);
                    color_available_player = true;
                    break;
            }
        }
        // 마법 카드 제거
        const delete_card_magic = (card_loc) => {
            console.log(`${card_loc} is deleted!`);
            let card_stat = String(card_stat_basic(main_field[card_loc] % 100));
            switch (card_loc) {
                case 'field5':
                    clear_field(field15)
                    enemygrave.push(main_field['field5'] % 100)
                    delete main_field.field5;
                    set_card(field15, enemygrave[enemygrave.length - 1]);
                    break;
                case 'field6':
                    clear_field(field15)
                    enemygrave.push(main_field['field6'] % 100)
                    delete main_field.field6;
                    set_card(field15, enemygrave[enemygrave.length - 1]);
                    break;
                case 'field7':
                    clear_field(field15)
                    enemygrave.push(main_field['field7'] % 100)
                    delete main_field.field7;
                    set_card(field15, enemygrave[enemygrave.length - 1]);
                    break;
                case 'field12':
                    clear_field(field16)
                    playergrave.push(main_field['field12'] % 100)
                    delete main_field.field12;
                    set_card(field16, playergrave[playergrave.length - 1]);
                    break;
                case 'field13':
                    clear_field(field16)
                    playergrave.push(main_field['field13'] % 100)
                    delete main_field.field13;
                    set_card(field16, playergrave[playergrave.length - 1]);
                    break;
                case 'field14':
                    clear_field(field16)
                    playergrave.push(main_field['field14'] % 100)
                    delete main_field.field14;
                    set_card(field16, playergrave[playergrave.length - 1]);
                    break;
            }
            switch (card_loc) {
                case 'field5':
                case 'field6':
                case 'field7':
                    switch (card_stat) {
                        case 'jack':
                            double_attack_enemy -= 1;
                            break;
                        case 'queen':
                            half_attack_player -= 1;
                            break;
                        case 'king':
                            double_attack_enemy -= 1;
                            half_attack_player -= 1;
                            break;
                    }
                    break;
                case 'field12':
                case 'field13':
                case 'field14':
                    switch (card_stat) {
                        case 'jack':
                            double_attack_player -= 1;
                            break;
                        case 'queen':
                            half_attack_enemy -= 1;
                            break;
                        case 'king':
                            double_attack_player -= 1;
                            half_attack_enemy -= 1;
                            break;
                    }
                    break;
            }
        };

        // 마법카드 효과
        const active_magic_card = (cardid, turn) => {
            console.log(`${turn}'s turn magic card: ${cardid}`)
            switch (turn) {
                case 'player':
                    let field5_stat = card_stat_basic(main_field['field5'] % 100);
                    let field6_stat = card_stat_basic(main_field['field6'] % 100);
                    let field7_stat = card_stat_basic(main_field['field7'] % 100);
                    switch (card_stat_basic(cardid)) {
                        case field5_stat:
                            delete_card_magic('field5');
                            return false;
                        case field6_stat:
                            delete_card_magic('field6');
                            return false;
                        case field7_stat:
                            delete_card_magic('field7');
                            return false;
                        case 'jack':
                            double_attack_player += 1;
                            return true;
                        case 'queen':
                            half_attack_enemy += 1;
                            return true;
                        case 'king':
                            double_attack_player += 1;
                            half_attack_enemy += 1;
                            return true;
                    }
                    break;
                case 'enemy':
                    let field12_stat = String(card_stat_basic(main_field['field12'] % 100));
                    let field13_stat = String(card_stat_basic(main_field['field13'] % 100));
                    let field14_stat = String(card_stat_basic(main_field['field14'] % 100));
                    switch (card_stat_basic(cardid)) {
                        case field12_stat:
                            delete_card_magic('field12');
                            return false;
                        case field13_stat:
                            delete_card_magic('field13');
                            return false;
                        case field14_stat:
                            delete_card_magic('field14');
                            return false;
                        case 'jack':
                            double_attack_enemy += 1;
                            return true;
                        case 'queen':
                            half_attack_player += 1;
                            return true;
                        case 'king':
                            double_attack_enemy += 1;
                            half_attack_player += 1;
                            return true;
                    }
                    break;
            }
        };

        // 카드정보를 받아 마법/공격/앞 여부를 확인하는 함수들
        // 진작에 만들걸
        const is_magic_card = (card) => {
            return card % 100000 > 10000;
        };
        const is_attack_card = (card) => {
            return card % 10000 > 1000;
        };
        const is_front_card = (card) => {
            return card % 1000 > 100;
        };

        // 직접 피해 함수
        const attack_directly = (player, damage) => {
            var audio = new Audio('{% static "resources/sfx/attack.wav" %}');
            audio.play();
            {% if request.session.skill == '신화계' %}
                var audio = new Audio('/static/resources/sfx/fire.wav');
            {% endif %}
            switch (player) {
                case 'player':
                    hp2 -= damage;
                    enemyhp.textContent = hp2;
                    alert(`${enemy_name}에 ${damage}피해`);
                    if (hp2 <= 0) win_game('player');
                    break;
                case 'enemy':
                    hp1 -= damage;
                    player_hp.value = hp1;
                    playerhp.innerHTML = hp1;
                    alert(`플레이어에 ${damage}피해`);
                    if (hp1 <= 0) win_game('enemy');
                    break;
            }
        };
        // 게임종료, 승패출력
        const win_game = (winner) => {
            win_form.value = winner;
            btfrm.submit()
            switch (winner) {
                case 'player':
                    btfrm.submit()
                {#location.replace('/ifwin')#}
                    break;
                case 'enemy':
                {#location.replace('/iflose')#}
                    break;
            }
        };

        // 숫자 버프 부여 (패시브)
        const check_buff_number = () => {
            let player_field = [];
            if (is_front_card(main_field['field8'])) player_field.push(card_num(main_field['field8'] % 100));
            else player_field.push(0);
            if (is_front_card(main_field['field9'])) player_field.push(card_num(main_field['field9'] % 100));
            else player_field.push(0);
            if (is_front_card(main_field['field10'])) player_field.push(card_num(main_field['field10'] % 100));
            else player_field.push(0);
            if (is_front_card(main_field['field11'])) player_field.push(card_num(main_field['field11'] % 100));
            else player_field.push(0);


            let check_straight = [];

            // 동일값 확인
            for (let i = 0; i < 4; ++i) {
                if (!(player_field[i] === 0)) {
                    check_straight.push(player_field[i]);
                    let buff_type = player_field.filter(e => player_field[i] === e).length;
                    if (buff_type > 1) {
                        if (buff_pair[`field${i + 8}`] < buff_type) buff_pair[`field${i + 8}`] = buff_type;
                    }
                }
            }

            // 순차배열 확인
            if (check_straight.length >= 3) {
                let temp = 0;
                let is_straight = true;
                let non_straight;
                check_straight.sort((a, b) => a - b);
                const set = new Set(check_straight);
                let check_straight2 = [...set];
                let stat = check_straight2[0];
                for (let i = 1; i < check_straight2.length; ++i) {
                    if (check_straight2[i - 1] + 1 === check_straight2[i]) {
                        stat += check_straight2[i];
                    } else {
                        if (!(temp === 0)) is_straight = false;
                        temp = i;
                    }
                }
                const buff_player = (num) => {
                    buff_straight['field8'] = num;
                    buff_straight['field9'] = num;
                    buff_straight['field10'] = num;
                    buff_straight['field11'] = num;
                };
                buff_player(0);
                if (is_straight) {
                    if (check_straight.length === 4 && temp === 0) {
                        buff_player(stat);
                    } else if (check_straight2.length === 3 && temp === 0) {
                        buff_player(stat);
                        non_straight = `field${player_field.indexOf(0) + 8}`;
                        if (non_straight !== 'field7') buff_straight[non_straight] = 0;
                    } else if (check_straight2.length === 4 && temp === 1) {
                        buff_player(stat);
                        non_straight = `field${player_field.indexOf(check_straight[0]) + 8}`;
                        if (non_straight !== 'field7') buff_straight[non_straight] = 0;
                    } else if (check_straight2.length === 4 && temp === 3) {
                        buff_player(stat);
                        non_straight = `field${player_field.indexOf(check_straight[3]) + 8}`;
                        if (non_straight !== 'field7') buff_straight[non_straight] = 0;
                    }
                }
            }


            let enemy_field = [];
            if (is_front_card(main_field['field1'])) enemy_field.push(card_num(main_field['field1'] % 100));
            else enemy_field.push(0);
            if (is_front_card(main_field['field2'])) enemy_field.push(card_num(main_field['field2'] % 100));
            else enemy_field.push(0);
            if (is_front_card(main_field['field3'])) enemy_field.push(card_num(main_field['field3'] % 100));
            else enemy_field.push(0);
            if (is_front_card(main_field['field4'])) enemy_field.push(card_num(main_field['field4'] % 100));
            else enemy_field.push(0);

            // 동일값 확인
            for (let i = 0; i < 4; ++i) {
                if (!(enemy_field[i] === 0)) {
                    check_straight.push(player_field[i]);
                    let buff_type = enemy_field.filter(e => enemy_field[i] === e).length;
                    if (buff_type > 1) {
                        if (buff_pair[`field${i + 1}`] < buff_type) buff_pair[`field${i + 1}`] = buff_type;
                    }
                }
            }

            check_straight = [];
            // 순차배열 확인
            if (check_straight.length >= 3) {
                let temp = 0;
                let is_straight = true;
                let non_straight;
                check_straight.sort((a, b) => a - b);
                const set = new Set(check_straight);
                let check_straight2 = [...set];
                let stat = check_straight2[0];
                for (let i = 1; i < check_straight2.length; ++i) {
                    if (check_straight2[i - 1] + 1 === check_straight2[i]) {
                        stat += check_straight2[i];
                    } else {
                        if (!(temp === 0)) is_straight = false;
                        temp = i;
                    }
                }
                const buff_enemy = (num) => {
                    buff_straight['field1'] = num;
                    buff_straight['field2'] = num;
                    buff_straight['field3'] = num;
                    buff_straight['field4'] = num;
                };
                buff_enemy(0);
                if (is_straight) {
                    if (check_straight.length === 4 && temp === 0) {
                        buff_enemy(stat);
                    } else if (check_straight2.length === 3 && temp === 0) {
                        buff_enemy(stat);
                        non_straight = `field${player_field.indexOf(0) + 1}`;
                        if (non_straight !== 'field0') buff_straight[non_straight] = 0;
                    } else if (check_straight2.length === 4 && temp === 1) {
                        buff_enemy(stat);
                        non_straight = `field${player_field.indexOf(check_straight[0]) + 1}`;
                        if (non_straight !== 'field0') buff_straight[non_straight] = 0;
                    } else if (check_straight2.length === 4 && temp === 3) {
                        buff_enemy(stat);
                        non_straight = `field${player_field.indexOf(check_straight[3]) + 1}`;
                        if (non_straight !== 'field0') buff_straight[non_straight] = 0;
                    }
                }
            }
        };

        // 같은 모양 버프 부여 (엑티브)
        const check_buff_shape = () => {
            let player_field = [];
            if (is_front_card(main_field['field8'])) player_field.push(card_shape_basic(main_field['field8'] % 100));
            else player_field.push(0);
            if (is_front_card(main_field['field9'])) player_field.push(card_shape_basic(main_field['field9'] % 100));
            else player_field.push(0);
            if (is_front_card(main_field['field10'])) player_field.push(card_shape_basic(main_field['field10'] % 100));
            else player_field.push(0);
            if (is_front_card(main_field['field11'])) player_field.push(card_shape_basic(main_field['field11'] % 100));
            else player_field.push(0);

            const active_skills_player = (skill) => {
                switch (skill) {
                    case 2:
                        if (is_front_card(main_field['field1'])) debuff_shape['field1']++;
                        if (is_front_card(main_field['field2'])) debuff_shape['field2']++;
                        if (is_front_card(main_field['field3'])) debuff_shape['field3']++;
                        if (is_front_card(main_field['field4'])) debuff_shape['field4']++;
                        break;
                    case 3:
                        let field = [];
                        if (main_field['field1']) field.push('field1');
                        if (main_field['field2']) field.push('field2');
                        if (main_field['field3']) field.push('field3');
                        if (main_field['field4']) field.push('field4');
                        if (field.length > 0) {
                            delete_card_normal(field[Math.floor(Math.random() * field.length)]);
                        }
                        break;
                    case 4:
                        if (main_field['field1']) delete_card_normal('field1');
                        if (main_field['field2']) delete_card_normal('field2');
                        if (main_field['field3']) delete_card_normal('field3');
                        if (main_field['field4']) delete_card_normal('field4');
                        break;
                }
            };
            let check_skills = [];

            // 동일값 확인
            for (let i = 0; i < 4; ++i) {
                if (!(player_field[i] === 0)) {
                    let buff_type = player_field.filter(e => player_field[i] === e).length;
                    if (buff_type > 1) {
                        if (active_shape[`field${i + 8}`] < buff_type) {
                            active_shape[`field${i + 8}`] = buff_type;
                            check_skills.push(buff_type);
                        }
                    }
                }
            }
            console.log(`player's active skill check`)
            console.log(check_skills)
            if (check_skills.includes(2)) active_skills_player(2);
            else if (check_skills.includes(3)) active_skills_player(3);
            else if (check_skills.includes(4)) active_skills_player(4);


            let enemy_field = [];
            if (is_front_card(main_field['field1'])) enemy_field.push(card_shape_basic(main_field['field1'] % 100));
            else enemy_field.push(0);
            if (is_front_card(main_field['field2'])) enemy_field.push(card_shape_basic(main_field['field2'] % 100));
            else enemy_field.push(0);
            if (is_front_card(main_field['field3'])) enemy_field.push(card_shape_basic(main_field['field3'] % 100));
            else enemy_field.push(0);
            if (is_front_card(main_field['field4'])) enemy_field.push(card_shape_basic(main_field['field4'] % 100));
            else enemy_field.push(0);

            const active_skills_enemy = (skill) => {
                switch (skill) {
                    case 2:
                        if (is_front_card(main_field['field8'])) debuff_shape['field8']++;
                        if (is_front_card(main_field['field9'])) debuff_shape['field9']++;
                        if (is_front_card(main_field['field10'])) debuff_shape['field10']++;
                        if (is_front_card(main_field['field11'])) debuff_shape['field11']++;
                        break;
                    case 3:
                        let field = [];
                        if (main_field['field8']) field.push('field8');
                        if (main_field['field9']) field.push('field9');
                        if (main_field['field10']) field.push('field10');
                        if (main_field['field11']) field.push('field11');
                        if (field.length > 0) {
                            delete_card_normal(field[Math.floor(Math.random() * field.length)]);
                        }
                        break;
                    case 4:
                        if (main_field['field8']) delete_card_normal('field8');
                        if (main_field['field9']) delete_card_normal('field9');
                        if (main_field['field10']) delete_card_normal('field10');
                        if (main_field['field11']) delete_card_normal('field11');
                        break;
                }
            };
            check_skills = [];

            // 동일값 확인
            for (let i = 0; i < 4; ++i) {
                if (!(enemy_field[i] === 0)) {
                    let buff_type = enemy_field.filter(e => enemy_field[i] === e).length;
                    if (buff_type > 1) {
                        if (active_shape[`field${i + 1}`] < buff_type) {
                            active_shape[`field${i + 1}`] = buff_type;
                            check_skills.push(buff_type);
                        }
                    }
                }
            }
            console.log(`enemy's active skill check`)
            console.log(check_skills)
            if (check_skills.includes(2)) active_skills_enemy(2);
            else if (check_skills.includes(3)) active_skills_enemy(3);
            else if (check_skills.includes(4)) active_skills_enemy(4);

        };

        const check_buff_color = () => {
            let player_field = [];
            if (is_front_card(main_field['field8'])) player_field.push(card_color_basic(main_field['field8'] % 100));
            if (is_front_card(main_field['field9'])) player_field.push(card_color_basic(main_field['field9'] % 100));
            if (is_front_card(main_field['field10'])) player_field.push(card_color_basic(main_field['field10'] % 100));
            if (is_front_card(main_field['field11'])) player_field.push(card_color_basic(main_field['field11'] % 100));
            if (player_field.length === 4 && color_available_player) {
                console.log(`player's normal field is full----------------`);
                console.log(player_field);
                console.log(`black: ${player_field.filter(e => 'black' === e).length}`);
                console.log(`red: ${player_field.filter(e => 'red' === e).length}`);
                if (player_field.filter(e => 'black' === e).length === 4) {
                    let field = [];
                    if (main_field['field5']) field.push('field5');
                    if (main_field['field6']) field.push('field6');
                    if (main_field['field7']) field.push('field7');
                    if (field.length > 0) {
                        delete_card_magic(field[Math.floor(Math.random() * field.length)]);
                    }
                    color_available_player = false;
                } else if (player_field.filter(e => 'red' === e).length === 4) {
                    if (main_field['field5']) delete_card_magic('field5');
                    if (main_field['field6']) delete_card_magic('field6');
                    if (main_field['field7']) delete_card_magic('field7');
                    color_available_player = false;
                }
            }
            let enemy_field = [];
            if (is_front_card(main_field['field1'])) enemy_field.push(card_color_basic(main_field['field1'] % 100));
            if (is_front_card(main_field['field2'])) enemy_field.push(card_color_basic(main_field['field2'] % 100));
            if (is_front_card(main_field['field3'])) enemy_field.push(card_color_basic(main_field['field3'] % 100));
            if (is_front_card(main_field['field4'])) enemy_field.push(card_color_basic(main_field['field4'] % 100));
            if (enemy_field.length === 4 && color_available_player) {
                console.log(`enemy's normal field is full----------------`);
                console.log(enemy_field);
                console.log(`black: ${enemy_field.filter(e => 'black' === e).length}`);
                console.log(`red: ${enemy_field.filter(e => 'red' === e).length}`);
                if (enemy_field.filter(e => 'black' === e).length === 4) {
                    let field = [];
                    if (main_field['field12']) field.push('field12');
                    if (main_field['field13']) field.push('field13');
                    if (main_field['field14']) field.push('field14');
                    if (field.length > 0) {
                        delete_card_magic(field[Math.floor(Math.random() * field.length)]);
                    }
                    color_available_enemy = false;
                } else if (enemy_field.filter(e => 'red' === e).length === 4) {
                    if (main_field['field12']) delete_card_magic('field12');
                    if (main_field['field13']) delete_card_magic('field13');
                    if (main_field['field14']) delete_card_magic('field14');
                    color_available_enemy = false;
                }
            }
        }
        // 배열에서 특정값 찾아서 지우기
        const delete_card_from_array = (array, value) => {
            let inx = array.indexOf(value);
            return array.splice(inx, 1);
        };

        // 전술스킬 발동 버튼
        skill.addEventListener('click', () => {
            let skill_name = player_skill;
            user_skill_count++;
            user_skill(skill_name);
            win_game('player');
            console.log(`${skill_name}skill activated`)
            card_location();
            finish_turn();
        });

        // 스킬에 따른 패시브 효과용 함수
        const check_user_skill = (skill_name) => {
            const add_attack_stat = (num) => {
                if (is_attack_card(main_field['field8'])) user_special_add_stat['field8'] = num;
                if (is_attack_card(main_field['field9'])) user_special_add_stat['field9'] = num;
                if (is_attack_card(main_field['field10'])) user_special_add_stat['field10'] = num;
                if (is_attack_card(main_field['field11'])) user_special_add_stat['field11'] = num;
            };
            const add_defence_stat = (num) => {
                if (!is_attack_card(main_field['field8'])) user_special_add_stat['field8'] = num;
                if (!is_attack_card(main_field['field9'])) user_special_add_stat['field9'] = num;
                if (!is_attack_card(main_field['field10'])) user_special_add_stat['field10'] = num;
                if (!is_attack_card(main_field['field11'])) user_special_add_stat['field11'] = num;
            };
            const multiply_all_stat = (num) => {
                if (main_field['field8']) user_special_multiply_stat['field8'] = num;
                if (main_field['field9']) user_special_multiply_stat['field9'] = num;
                if (main_field['field10']) user_special_multiply_stat['field10'] = num;
                if (main_field['field11']) user_special_multiply_stat['field11'] = num;
            };
            switch (skill_name) {
                case '복병':
                case '복병신속':
                    magic_card_in_deck = player_deck.filter(ismagic);
                    skill_available = String(magic_card_in_deck) !== '';
                    break;
                case '노당익장':
                    skill_available = false;
                    add_attack_stat(2);
                    add_defence_stat(-1);
                    break;
                case '맹공':
                    skill_available = false;
                    add_attack_stat(3);
                    add_defence_stat(-5);
                    break;
                case '강용':
                    skill_available = false;
                    add_defence_stat(2);
                    break;
                case '철벽':
                    skill_available = false;
                    add_attack_stat(-2);
                    add_defence_stat(3);
                    break;
                case '강습':
                    skill_available = false;
                    multiply_all_stat(2);
                    // 1/10확률로 턴 넘어감
                    user_turn_skip = Math.floor(Math.random() * 10) === 0;
                    break;
                case '없음':
                case '만인적':
                    skill_available = false;
                    break;
                case '위무지강':
                    magic_card_in_deck = player_deck.filter(ismagic);
                    if (String(magic_card_in_deck) !== '') {
                        shuffle(magic_card_in_deck);
                        have_jack = false;
                        have_queen = false;
                        have_king = false;
                        for (let i = 0; i < magic_card_in_deck.length; ++i) {
                            if (String(card_stat_basic(magic_card_in_deck[i])) === 'jack') {
                                have_jack = true;
                                jack = magic_card_in_deck[i];
                            }
                            if (String(card_stat_basic(magic_card_in_deck[i])) === 'queen') {
                                have_queen = true;
                                queen = magic_card_in_deck[i];
                            }
                            if (String(card_stat_basic(magic_card_in_deck[i])) === 'king') {
                                have_king = true;
                                king = magic_card_in_deck[i];
                            }
                        }

                        if (have_jack && have_queen && have_king) {
                            main_field['field12'] = 11100 + Number(jack);
                            main_field['field13'] = 11100 + Number(queen);
                            main_field['field14'] = 11100 + Number(king);
                            delete_card_from_array(player_deck, jack);
                            delete_card_from_array(player_deck, queen);
                            delete_card_from_array(player_deck, king);
                        }
                    }
                    user_skill_passive = false;
                    skill_available = false;
                    card_location();
                    break;
                case '방호':
                    skill_available = false;
                    add_attack_stat(-5);
                    add_defence_stat(10);
                    break;
                case '팔진도':
                    skill_available = false;
                    double_draw = true;
                    break;
                case '신화계':
                    skill_available = false;
                    enemy_turn_damage = 15;
                    break;
                default:
                    break;
            }
        }


        // 전술스킬 발동 함수
        const user_skill = (skill_name) => {
            let user = 'player';
            const add_attack_stat = (num) => {
                if (is_attack_card(main_field['field8'])) user_special_add_stat['field8'] += num;
                if (is_attack_card(main_field['field9'])) user_special_add_stat['field9'] += num;
                if (is_attack_card(main_field['field10'])) user_special_add_stat['field10'] += num;
                if (is_attack_card(main_field['field11'])) user_special_add_stat['field11'] += num;
            };
            const add_defence_stat = (num) => {
                if (!is_attack_card(main_field['field8'])) user_special_add_stat['field8'] += num;
                if (!is_attack_card(main_field['field9'])) user_special_add_stat['field9'] += num;
                if (!is_attack_card(main_field['field10'])) user_special_add_stat['field10'] += num;
                if (!is_attack_card(main_field['field11'])) user_special_add_stat['field11'] += num;
            };
            const multiply_all_stat = (num) => {
                if (main_field['field8']) user_special_multiply_stat['field8'] = user_special_multiply_stat['field8'] * num;
                if (main_field['field9']) user_special_multiply_stat['field9'] = user_special_multiply_stat['field9'] * num;
                if (main_field['field10']) user_special_multiply_stat['field10'] = user_special_multiply_stat['field10'] * num;
                if (main_field['field11']) user_special_multiply_stat['field11'] = user_special_multiply_stat['field11'] * num;
            };

            switch (skill_name) {
                case '공격강화':
                    alert(`${skill_name} 발동`);
                    var audio = new Audio('/static/resources/sfx/buff.wav');
                    audio.play();
                    add_attack_stat(1);
                    skill.innerText = `강화 ${user_skill_count}회`;
                    if (user_skill_count === 5) skill_available = false;
                    break;
                case '방어강화':
                    alert(`${skill_name} 발동`);
                    var audio = new Audio('/static/resources/sfx/buff.wav');
                    audio.play();
                    add_defence_stat(1);
                    skill.innerText = `강화 ${user_skill_count}회`;
                    if (user_skill_count === 5) skill_available = false;
                    break;
                case '매복지독':
                    dice = Math.floor(Math.random() * 100) + 1;
                    if (player_inteli > dice) {
                        alert(`${skill_name} 발동`);
                        attack_directly(user, dice);
                        attack_directly('enemy', 10);
                    } else alert(`${skill_name} 발동실패`);
                    break;
                case '속공':
                    alert(`${skill_name} 발동`);
                    multiply_all_stat(0.5)
                    user_additional_turn = 2;
                    break;
                case '복병':
                    alert(`${skill_name} 발동`);
                    magic_card_in_deck = player_deck.filter(ismagic);
                    shuffle(magic_card_in_deck);
                    drowed_magic_card = player_deck.indexOf(magic_card_in_deck[0])
                    draw_card(player_hand, magic_card_in_deck);
                    checkhand(player_hand, playercard);
                    player_deck.splice(magic_card, 1);
                    break;
                case '복병신속':
                    alert(`${skill_name} 발동`);
                    var audio = new Audio('/static/resources/sfx/buff.wav');
                    audio.play();
                    magic_card_in_deck = player_deck.filter(ismagic);
                    shuffle(magic_card_in_deck);
                    drowed_magic_card = player_deck.indexOf(magic_card_in_deck[0])
                    draw_card(player_hand, magic_card_in_deck);
                    checkhand(player_hand, playercard);
                    player_deck.splice(magic_card, 1);

                    add_attack_stat(1);
                    skill.innerText = `강화 ${user_skill_count}회`;
                    if (user_skill_count === 5) skill_available = false;
                    break;
                case '공방일체':
                    alert(`${skill_name} 발동`);
                    var audio = new Audio('/static/resources/sfx/buff.wav');
                    audio.play();
                    add_attack_stat(1);
                    add_defence_stat(1);
                    skill.innerText = `강화 ${user_skill_count}회`;
                    if (user_skill_count === 5) skill_available = false;
                    break;
                case '운체풍신':
                    alert(`${skill_name} 발동`);
                    add_attack_stat(1);
                    add_defence_stat(1);
                    skill.innerText = `강화 ${user_skill_count}회`;
                    if (user_skill_count === 3) skill_available = false;
                    break;
                case '의용병':
                    alert(`${skill_name} 발동`);
                    for (let i = 0; i < 5; ++i) {
                        player_deck.shift()
                    }
                    if (playergrave.length > 1) {
                        playergrave.sort((a, b) => a - b);
                    }
                    break;
                case '용의 지혜':
                    alert(`${skill_name} 발동`);
                    if (main_field['field1']) if (card_stat_basic(main_field['field1']) !== 11) delete_card_normal('field1');
                    if (main_field['field2']) if (card_stat_basic(main_field['field2']) !== 11) delete_card_normal('field2');
                    if (main_field['field3']) if (card_stat_basic(main_field['field3']) !== 11) delete_card_normal('field3');
                    if (main_field['field4']) if (card_stat_basic(main_field['field4']) !== 11) delete_card_normal('field4');
                    if (main_field['field5']) delete_card_magic('field5');
                    if (main_field['field6']) delete_card_magic('field6');
                    if (main_field['field7']) delete_card_magic('field7');
                    attack_directly('enemy', 99);
                    break;
                case '대타격':
                    dice = Math.floor(Math.random() * 100) + 1;
                    if (player_power > dice) {
                        alert(`${skill_name} 발동`);
                        attack_directly('player', dice);
                        var audio = new Audio('/static/resources/sfx/bighit.wav');
                        audio.play();
                    } else alert(`${skill_name} 발동실패`);
                    break;
                case '화계':
                    dice = Math.floor(Math.random() * 100) + 1;
                    if (player_inteli > dice) {
                        alert(`${skill_name} 발동`);
                        attack_directly('player', dice);
                        var audio = new Audio('/static/resources/sfx/fire.wav');
                        audio.play();
                    } else alert(`${skill_name} 발동실패`);
                    break;
                case '신화계':
                    alert(`${skill_name} 발동`);
                    attack_directly('enemey', 15);
                    break;
                case '인중여포':
                    user_turn_skip = true;
                    dice = Math.floor(Math.random() * 100) + 1;
                    if (player_power > dice) {
                        alert(`${skill_name} 발동`);
                        attack_directly('player', dice);
                        var audio = new Audio('/static/resources/sfx/bighit.wav');
                        audio.play();
                        if (main_field['field1']) if (card_stat_basic(main_field['field1']) !== 11) delete_card_normal('field1');
                        if (main_field['field2']) if (card_stat_basic(main_field['field2']) !== 11) delete_card_normal('field2');
                        if (main_field['field3']) if (card_stat_basic(main_field['field3']) !== 11) delete_card_normal('field3');
                        if (main_field['field4']) if (card_stat_basic(main_field['field4']) !== 11) delete_card_normal('field4');
                        if (main_field['field5']) delete_card_magic('field5');
                        if (main_field['field6']) delete_card_magic('field6');
                        if (main_field['field7']) delete_card_magic('field7');
                    } else alert(`${skill_name} 발동실패`);
                    break;
                default:
                    return false
            }
        }
        // 플레이어 풀 필드 확인
        const check_full_field = () => {
            if (isfieldfull_player_normal() && isfieldfull_player_magic()) {
                fullField.style.display = 'inline-block'
                giveUp.style.display = 'none';
            } else fullField.style.display = 'none'
        };
        // 풀 필드 효과 발동
        fullField.addEventListener('click', () => {
            fullField.style.display = 'none';
            delete_card_normal('field8');
            delete_card_normal('field9');
            delete_card_normal('field10');
            delete_card_normal('field11');
            delete_card_magic('field12');
            delete_card_magic('field13');
            delete_card_magic('field14');
            if (main_field['field1']) delete_card_normal('field1');
            if (main_field['field2']) delete_card_normal('field2');
            if (main_field['field3']) delete_card_normal('field3');
            if (main_field['field4']) delete_card_normal('field4');
            if (main_field['field5']) delete_card_magic('field5');
            if (main_field['field6']) delete_card_magic('field6');
            if (main_field['field7']) delete_card_magic('field7');
            main_field['field8'] = 101103;
            if (player_deck.includes(3)) {
                delete_card_from_array(player_deck, 3);
            } else if (enemy_deck.includes(3)) {
                delete_card_from_array(enemy_deck, 3);
            } else if (player_hand.includes(3)) {
                delete_card_from_array(player_hand, 3);
                checkhand(player_hand, playercard);
            } else if (enemy_hand.includes(3)) {
                delete_card_from_array(enemy_hand, 3);
                enemycard.removeChild(enemycard.lastElementChild);
            }
            card_location();
        });
        giveUp.addEventListener('click', () => {
            if (confirm(`
덱을 전부 소모했습니다.
항복하시겠습니까?
            `)) win_game('enemy');
        });


        // 무덤 스킬 가능여부 확인
        const check_grave = () => {
            let iscolor = [];
            let isnumber = [];
            let a;

            for (let i = 0; i < playergrave.length; ++i) {
                a = card_color_basic(playergrave[i]);
                iscolor.push(a);
            }
            for (let i = 0; i < playergrave.length; ++i) {
                a = card_num(playergrave[i]);
                isnumber.push(a);
            }

            for (let i = 0; i < iscolor.length; ++i) {
                let mycolor = iscolor[i];

                if (i > 2 && grave_skill === 0) {
                    if (iscolor[i - 1] === mycolor) {
                        grave_skill = 2;
                        active_card_for_grave_skills = [];
                        active_card_for_grave_skills.push(playergrave[i - 1]);
                        active_card_for_grave_skills.push(playergrave[i]);
                        grave.innerText = '무덤효과 (2장)';
                    }
                }

                if (i > 3 && grave_skill < 3) {
                    if (iscolor[i - 2] === mycolor &&
                        iscolor[i - 1] === mycolor) {
                        grave_skill = 3;
                        active_card_for_grave_skills = [];
                        active_card_for_grave_skills.push(playergrave[i - 2]);
                        active_card_for_grave_skills.push(playergrave[i - 1]);
                        active_card_for_grave_skills.push(playergrave[i]);
                        grave.innerText = '무덤효과 (3장)';
                    }
                }

                if (i > 4 && grave_skill < 4) {
                    if (iscolor[i - 3] === mycolor &&
                        iscolor[i - 2] === mycolor &&
                        iscolor[i - 1] === mycolor) {
                        grave_skill = 4;
                        active_card_for_grave_skills = [];
                        active_card_for_grave_skills.push(playergrave[i - 3]);
                        active_card_for_grave_skills.push(playergrave[i - 2]);
                        active_card_for_grave_skills.push(playergrave[i - 1]);
                        active_card_for_grave_skills.push(playergrave[i]);
                        grave.innerText = '무덤효과 (4장)';
                    }
                }

            }

            for (let i = 0; i < isnumber.length; ++i) {
                let mynumber = isnumber[i];

                if (i > 2 && grave_skill === 0) {
                    if (isnumber[i - 1] === mynumber) {
                        grave_skill = 2;
                        active_card_for_grave_skills = [];
                        active_card_for_grave_skills.push(playergrave[i - 1]);
                        active_card_for_grave_skills.push(playergrave[i]);
                        grave.innerText = '무덤효과 (2장)';
                    }
                }

                if (i > 3 && grave_skill < 3) {
                    if (isnumber[i - 2] === mynumber &&
                        isnumber[i - 1] === mynumber) {
                        grave_skill = 3;
                        active_card_for_grave_skills = [];
                        active_card_for_grave_skills.push(playergrave[i - 2]);
                        active_card_for_grave_skills.push(playergrave[i - 1]);
                        active_card_for_grave_skills.push(playergrave[i]);
                        grave.innerText = '무덤효과 (3장)';
                    }
                }

                if (i > 4 && grave_skill < 4) {
                    if (isnumber[i - 3] === mynumber &&
                        isnumber[i - 2] === mynumber &&
                        isnumber[i - 1] === mynumber) {
                        grave_skill = 4;
                        active_card_for_grave_skills = [];
                        active_card_for_grave_skills.push(playergrave[i - 3]);
                        active_card_for_grave_skills.push(playergrave[i - 2]);
                        active_card_for_grave_skills.push(playergrave[i - 1]);
                        active_card_for_grave_skills.push(playergrave[i]);
                        grave.innerText = '무덤효과 (4장)';
                    }
                }
            }
            console.log('active_card_for_grave_skills');
            console.log(active_card_for_grave_skills);
        }

        // 무덤 스킬 발동
        grave.addEventListener('click', () => {
            grave.innerText = '무덤효과';
            for (let i = 0; i < active_card_for_grave_skills.length; ++i) {
                delete_card_from_array(playergrave, active_card_for_grave_skills[i]);
            }
            let field = [];
            switch (grave_skill) {
                case 2:
                    field = []
                    if (is_front_card(main_field['field1'])) field.push('field1');
                    if (is_front_card(main_field['field2'])) field.push('field2');
                    if (is_front_card(main_field['field3'])) field.push('field3');
                    if (is_front_card(main_field['field4'])) field.push('field4');
                    if (field.length > 0) {
                        let a = field[Math.floor(Math.random() * field.length)];
                        debuff_shape[a]++;
                    }
                    break;
                case 3:
                    enemy_deck.shift();
                    break;
                case 4:
                    field = []
                    if (is_front_card(main_field['field1'])) field.push('field1');
                    if (is_front_card(main_field['field2'])) field.push('field2');
                    if (is_front_card(main_field['field3'])) field.push('field3');
                    if (is_front_card(main_field['field4'])) field.push('field4');
                    if (field.length > 0) {
                        let a = field[Math.floor(Math.random() * field.length)];
                        debuff_shape[a]++;
                    }
                    enemy_deck.shift();
                    break;
            }

            finish_turn();
        });
        first_turn();
    </script>
{% endblock %}